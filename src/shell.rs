use std::path::PathBuf;
use std::fs;
use std::io::Write;
use std::process::Command;
use anyhow::{Result, Context};

#[derive(Debug)]
pub enum ShellType {
    Zsh,
    Bash,
    Fish,
    Unknown,
}

impl ShellType {
    pub fn detect() -> Result<Self> {
        let shell = std::env::var("SHELL")
            .context("Failed to detect shell")?;
        
        if shell.contains("zsh") {
            Ok(Self::Zsh)
        } else if shell.contains("bash") {
            Ok(Self::Bash)
        } else if shell.contains("fish") {
            Ok(Self::Fish)
        } else {
            Ok(Self::Unknown)
        }
    }

    pub fn config_file(&self) -> Option<PathBuf> {
        let home = dirs::home_dir()?;
        
        match self {
            Self::Zsh => Some(home.join(".zshrc")),
            Self::Bash => Some(home.join(".bashrc")),
            Self::Fish => Some(home.join(".config/fish/config.fish")),
            Self::Unknown => None,
        }
    }
}

const MKCD_FUNCTION: &str = r#"
# EE3 CLI FUNCTIONS
# This function is automatically generated by ee3 init
ee3() {
  # Handle mkcd command
  if [ "$1" = "mkcd" ] && [ -n "$2" ]; then
    local dir="$2"
    
    # Create directory and all parent directories
    mkdir -p "$dir" || return 1
    
    # Change to the directory
    cd "$dir" || return 1
    
    # Print the new directory
    pwd
    return 0
  fi
  
  # For all other commands, pass them through to the actual ee3 binary
  command ee3 "$@"
}

# END EE3 CLI FUNCTIONS
"#;

pub fn setup_shell_function() -> Result<PathBuf> {
    let shell = ShellType::detect()?;
    let config_file = shell.config_file()
        .ok_or_else(|| anyhow::anyhow!("Could not determine shell config file"))?;
    
    if let Some(parent) = config_file.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }
    
    let config_content = fs::read_to_string(&config_file).unwrap_or_default();
    
    if !config_content.contains("# EE3 CLI FUNCTIONS") {
        let mut file = fs::OpenOptions::new()
            .write(true)
            .append(true)
            .create(true)
            .open(&config_file)?;
            
        writeln!(file, "\n{}", MKCD_FUNCTION)?;
        
        source_shell_config(&shell, &config_file)?;
    }
    
    Ok(config_file)
}

fn source_shell_config(shell: &ShellType, config_file: &std::path::Path) -> Result<()> {
    match shell {
        ShellType::Zsh | ShellType::Bash => {
            let status = Command::new("bash")
                .arg("-c")
                .arg(format!("source {}", config_file.display()))
                .status()?;
                
            if !status.success() {
                anyhow::bail!("Failed to source shell config");
            }
        },
        ShellType::Fish => {
            let status = Command::new("fish")
                .arg("-c")
                .arg(format!("source {}", config_file.display()))
                .status()?;
                
            if !status.success() {
                anyhow::bail!("Failed to source fish config");
            }
        },
        ShellType::Unknown => {
            anyhow::bail!("Unknown shell type");
        }
    }
    
    Ok(())
}
